<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Prettier Format Test Runner</title>
  </head>
  <body>
    <h1>Prettier Format Test Runner</h1>
    <div id="status">Ready</div>

    <script>
      // Browser-based format test runner
      window.prettierFormatTestRunner = {
        ready: false,
        prettier: null,
        plugins: {},

        // Initialize with prettier and plugins
        async init(prettierGlobal, pluginsGlobal) {
          this.prettier = prettierGlobal;
          this.plugins = pluginsGlobal;
          this.ready = true;
          document.getElementById("status").textContent = "Initialized";
        },

        // Format code with given options
        async format(code, options) {
          if (!this.ready) {
            throw new Error("Format test runner not initialized");
          }

          try {
            const plugins = [];
            if (options.parser) {
              // Map parser to required plugins
              const parserPluginMap = {
                babel: ["babel", "estree"],
                flow: ["flow", "estree"],
                typescript: ["typescript", "estree"],
                "babel-ts": ["babel", "estree"],
                "babel-flow": ["babel", "estree"],
                json: ["babel", "estree"],
                json5: ["babel", "estree"],
                "json-stringify": ["babel", "estree"],
                css: ["postcss"],
                less: ["postcss"],
                scss: ["postcss"],
                html: ["html"],
                vue: ["html"],
                angular: ["angular", "html"],
                markdown: ["markdown"],
                mdx: ["mdx"],
                yaml: ["yaml"],
                graphql: ["graphql"],
                glimmer: ["glimmer"],
              };

              const requiredPlugins = parserPluginMap[options.parser] || [
                options.parser,
              ];
              for (const pluginName of requiredPlugins) {
                if (this.plugins[pluginName]) {
                  plugins.push(this.plugins[pluginName]);
                }
              }
            }

            const formatOptions = {
              ...options,
              plugins,
            };

            const formatted = await this.prettier.format(code, formatOptions);
            return { formatted, error: null };
          } catch (error) {
            return {
              formatted: null,
              error: {
                message: error.message,
                name: error.name,
                stack: error.stack,
              },
            };
          }
        },

        // Format with cursor
        async formatWithCursor(code, options) {
          if (!this.ready) {
            throw new Error("Format test runner not initialized");
          }

          try {
            const plugins = [];
            if (options.parser) {
              const parserPluginMap = {
                babel: ["babel", "estree"],
                flow: ["flow", "estree"],
                typescript: ["typescript", "estree"],
                "babel-ts": ["babel", "estree"],
                css: ["postcss"],
                html: ["html"],
                markdown: ["markdown"],
                yaml: ["yaml"],
                graphql: ["graphql"],
              };

              const requiredPlugins = parserPluginMap[options.parser] || [
                options.parser,
              ];
              for (const pluginName of requiredPlugins) {
                if (this.plugins[pluginName]) {
                  plugins.push(this.plugins[pluginName]);
                }
              }
            }

            const formatOptions = {
              ...options,
              plugins,
            };

            const result = await this.prettier.formatWithCursor(
              code,
              formatOptions,
            );
            return { result, error: null };
          } catch (error) {
            return {
              result: null,
              error: {
                message: error.message,
                name: error.name,
                stack: error.stack,
              },
            };
          }
        },
      };
    </script>
  </body>
</html>
